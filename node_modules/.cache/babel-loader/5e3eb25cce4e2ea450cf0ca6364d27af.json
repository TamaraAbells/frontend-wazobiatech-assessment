{"ast":null,"code":"/*\n * ! @chakra-ui/vue v0.12.0 by Jonathan Bakebwa @codebender828\n * MIT License\n * https://github.com/chakra-ui/chakra-ui-vue\n */\nimport { H as HTMLElement$1, J as useId, o as canUseDOM, N as createChainedFunction, P as isVueComponent, m as merge } from './index-2557a15f.js';\nimport './chakra-ui-styled-system.esm-36097b89.js';\nimport { C as ClickOutside } from './clickoutside.directive-97f28484.js';\nimport { css } from '@emotion/css';\nimport 'vue';\nimport './color-mode-observer-d3e4ca7f.js';\nimport CBox from './CBox.js';\nimport CPseudoBox from './CPseudoBox.js';\nimport CPortal from './CPortal.js';\nimport './CNoSsr.js';\n\nfunction getBoundingClientRect(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    y: rect.top\n  };\n}\n/*:: import type { Window } from '../types'; */\n\n/*:: declare function getWindow(node: Node | Window): Window; */\n\n\nfunction getWindow(node) {\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView : window;\n  }\n\n  return node;\n}\n\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n/*:: declare function isElement(node: mixed): boolean %checks(node instanceof\n  Element); */\n\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof\n  HTMLElement); */\n\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe: assume body is always available\n  return (isElement(element) ? element.ownerDocument : element.document).documentElement;\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle$1(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n} // Composite means it takes into account transforms as well as layout.\n\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (!isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n} // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\n\n\nfunction getLayoutRect(element) {\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  };\n}\n\nfunction getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || // DOM Element detected\n    // $FlowFixMe: need a better way to handle this...\n    element.host || // ShadowRoot detected\n    // $FlowFixMe: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n\nfunction listScrollParents(element, list) {\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = getNodeName(scrollParent) === 'body';\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element); // Find the nearest non-table offsetParent\n\n  while (offsetParent && isTableElement(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static') {\n    return window;\n  }\n\n  return offsetParent || window;\n}\n\nvar top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar auto = 'auto';\nvar basePlacements = [top, bottom, right, left];\nvar start = 'start';\nvar end = 'end';\nvar clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar popper = 'popper';\nvar reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n\nfunction format(str) {\n  var arguments$1 = arguments;\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments$1[_key];\n  }\n\n  return [].concat(args).reduce(function (p, c) {\n    return p.replace(/%s/, c);\n  }, str);\n}\n\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s';\nvar MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available';\nvar VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];\n\nfunction validateModifiers(modifiers) {\n  modifiers.forEach(function (modifier) {\n    Object.keys(modifier).forEach(function (key) {\n      switch (key) {\n        case 'name':\n          if (typeof modifier.name !== 'string') {\n            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '\"name\"', '\"string\"', \"\\\"\" + String(modifier.name) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'enabled':\n          if (typeof modifier.enabled !== 'boolean') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"enabled\"', '\"boolean\"', \"\\\"\" + String(modifier.enabled) + \"\\\"\"));\n          }\n\n        case 'phase':\n          if (modifierPhases.indexOf(modifier.phase) < 0) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"phase\"', \"either \" + modifierPhases.join(', '), \"\\\"\" + String(modifier.phase) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'fn':\n          if (typeof modifier.fn !== 'function') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"fn\"', '\"function\"', \"\\\"\" + String(modifier.fn) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'effect':\n          if (typeof modifier.effect !== 'function') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"effect\"', '\"function\"', \"\\\"\" + String(modifier.fn) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'requires':\n          if (!Array.isArray(modifier.requires)) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requires\"', '\"array\"', \"\\\"\" + String(modifier.requires) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'requiresIfExists':\n          if (!Array.isArray(modifier.requiresIfExists)) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requiresIfExists\"', '\"array\"', \"\\\"\" + String(modifier.requiresIfExists) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'options':\n        case 'data':\n          break;\n\n        default:\n          console.error(\"PopperJS: an invalid property has been provided to the \\\"\" + modifier.name + \"\\\" modifier, valid properties are \" + VALID_PROPERTIES.map(function (s) {\n            return \"\\\"\" + s + \"\\\"\";\n          }).join(', ') + \"; but \\\"\" + key + \"\\\" was provided.\");\n      }\n\n      modifier.requires && modifier.requires.forEach(function (requirement) {\n        if (modifiers.find(function (mod) {\n          return mod.name === requirement;\n        }) == null) {\n          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));\n        }\n      });\n    });\n  });\n}\n\nfunction uniqueBy(arr, fn) {\n  var identifiers = new Set();\n  return arr.filter(function (item) {\n    var identifier = fn(item);\n\n    if (!identifiers.has(identifier)) {\n      identifiers.add(identifier);\n      return true;\n    }\n  });\n}\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\n\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, {}, current, {\n      options: Object.assign({}, existing.options, {}, current.options),\n      data: Object.assign({}, existing.data, {}, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}\n\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  var arguments$1 = arguments;\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments$1[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, {}, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, {}, state.options, {}, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (process.env.NODE_ENV !== \"production\") {\n          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === 'flip';\n            });\n\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n\n          var _getComputedStyle = getComputedStyle$1(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (process.env.NODE_ENV !== \"production\") {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar eventListeners = {\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n};\n\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);\n        break;\n    }\n  }\n\n  return offsets;\n}\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name; // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar popperOffsets$1 = {\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n};\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsets(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive;\n\n  var _roundOffsets = roundOffsets(offsets),\n      x = _roundOffsets.x,\n      y = _roundOffsets.y;\n\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n    /*:: offsetParent = (offsetParent: Element); */\n\n\n    if (placement === top) {\n      sideY = bottom;\n      y -= offsetParent.clientHeight - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left) {\n      sideX = right;\n      x -= offsetParent.clientWidth - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref3) {\n  var state = _ref3.state,\n      options = _ref3.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';\n\n    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {\n      return transitionProperty.indexOf(property) >= 0;\n    })) {\n      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', '\\n\\n', 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\\n\\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));\n    }\n  }\n\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar computeStyles$1 = {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n}; // and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect$1(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe\n\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar applyStyles$1 = {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect$1,\n  requires: ['computeStyles']\n};\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar offset$1 = {\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n};\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\n\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\nvar hash$1 = {\n  start: 'end',\n  end: 'start'\n};\n\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash$1[matched];\n  });\n}\n\nfunction getViewportRect(element) {\n  var win = getWindow(element);\n  var visualViewport = win.visualViewport;\n  var width = win.innerWidth;\n  var height = win.innerHeight; // We don't know which browsers have buggy or odd implementations of this, so\n  // for now we're only applying it to iOS to fix the keyboard issue.\n  // Investigation required\n\n  if (visualViewport && /iPhone|iPod|iPad/.test(navigator.platform)) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: 0,\n    y: 0\n  };\n}\n\nfunction getDocumentRect(element) {\n  var win = getWindow(element);\n  var winScroll = getWindowScroll(element);\n  var documentRect = getCompositeRect(getDocumentElement(element), win);\n  documentRect.height = Math.max(documentRect.height, win.innerHeight);\n  documentRect.width = Math.max(documentRect.width, win.innerWidth);\n  documentRect.x = -winScroll.scrollLeft;\n  documentRect.y = -winScroll.scrollTop;\n  return documentRect;\n}\n\nfunction toNumber(cssValue) {\n  return parseFloat(cssValue) || 0;\n}\n\nfunction getBorders(element) {\n  var computedStyle = isHTMLElement(element) ? getComputedStyle$1(element) : {};\n  return {\n    top: toNumber(computedStyle.borderTopWidth),\n    right: toNumber(computedStyle.borderRightWidth),\n    bottom: toNumber(computedStyle.borderBottomWidth),\n    left: toNumber(computedStyle.borderLeftWidth)\n  };\n}\n\nfunction getDecorations(element) {\n  var win = getWindow(element);\n  var borders = getBorders(element);\n  var isHTML = getNodeName(element) === 'html';\n  var winScrollBarX = getWindowScrollBarX(element);\n  var x = element.clientWidth + borders.right;\n  var y = element.clientHeight + borders.bottom; // HACK:\n  // document.documentElement.clientHeight on iOS reports the height of the\n  // viewport including the bottom bar, even if the bottom bar isn't visible.\n  // If the difference between window innerHeight and html clientHeight is more\n  // than 50, we assume it's a mobile bottom bar and ignore scrollbars.\n  // * A 50px thick scrollbar is likely non-existent (macOS is 15px and Windows\n  //   is about 17px)\n  // * The mobile bar is 114px tall\n\n  if (isHTML && win.innerHeight - element.clientHeight > 50) {\n    y = win.innerHeight - borders.bottom;\n  }\n\n  return {\n    top: isHTML ? 0 : element.clientTop,\n    right: // RTL scrollbar (scrolling containers only)\n    element.clientLeft > borders.left ? borders.right : // LTR scrollbar\n    isHTML ? win.innerWidth - x - winScrollBarX : element.offsetWidth - x,\n    bottom: isHTML ? win.innerHeight - y : element.offsetHeight - y,\n    left: isHTML ? winScrollBarX : element.clientLeft\n  };\n}\n\nfunction contains(parent, child) {\n  // $FlowFixMe: hasOwnProperty doesn't seem to work in tests\n  var isShadow = Boolean(child.getRootNode && child.getRootNode().host); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (isShadow) {\n    var next = child;\n\n    do {\n      if (next && parent.isSameNode(next)) {\n        return true;\n      } // $FlowFixMe: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  } // Give up, the result is false\n\n\n  return false;\n}\n\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(element);\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement);\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    var decorations = getDecorations(isHTMLElement(clippingParent) ? clippingParent : getDocumentElement(element));\n    accRect.top = Math.max(rect.top + decorations.top, accRect.top);\n    accRect.right = Math.min(rect.right - decorations.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom - decorations.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left + decorations.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), {}, paddingObject);\n}\n\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var referenceElement = state.elements.reference;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(referenceElement);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, {}, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n/*:: type OverflowsMap = { [ComputedPlacement]: number }; */\n\n/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */\n\n\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements$1 = (variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements).filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  }); // $FlowFixMe: Flow seems to have problems with two array unions...\n\n  var overflows = placements$1.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") {\n        break;\n      }\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar flip$1 = {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};\n\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\nfunction within(min, value, max) {\n  return Math.max(min, Math.min(value, max));\n}\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var _preventedOffset = within(_min, _offset, _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar preventOverflow$1 = {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = state.modifiersData[name + \"#persistent\"].padding;\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect$2(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,\n      _options$padding = options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!isHTMLElement(arrowElement)) {\n      console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n    }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n  state.modifiersData[name + \"#persistent\"] = {\n    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar arrow$1 = {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect$2,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar hide$1 = {\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n};\nvar defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\nvar createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n/**\n * Evaluates popper arrow styles\n * @param {{ arrowSize: String, arrowShadowColor: String, hasArrow: Boolean}} props\n * @returns {String} Popper Arrow styles\n */\n\nvar getPopperArrowStyle = function getPopperArrowStyle(ref) {\n  var arrowSize = ref.arrowSize;\n  if (arrowSize === void 0) arrowSize = '1rem';\n  var arrowShadowColor = ref.arrowShadowColor;\n  if (arrowShadowColor === void 0) arrowShadowColor = 'rgba(0, 0, 0, 0.1)';\n  var hasArrow = ref.hasArrow;\n  if (hasArrow === void 0) hasArrow = true;\n  var bg = ref.bg;\n  if (bg === void 0) bg = 'inherit';\n  var popoverMargin = hasArrow ? \"calc(\" + arrowSize + \" / 2)\" : null;\n  var arrowPos = \"calc(\" + arrowSize + \" / 2 * -1)\";\n  return css({\n    display: 'none',\n    '[data-show]': {\n      display: 'block'\n    },\n    '[data-popper-arrow]': {\n      position: 'absolute',\n      zIndex: -1,\n      '&::before': {\n        content: '\"\"',\n        transform: 'rotate(45deg)',\n        backgroundColor: bg,\n        display: 'block',\n        width: arrowSize,\n        height: arrowSize\n      }\n    },\n    '&[data-popper-placement^=\"top\"]': {\n      marginBottom: popoverMargin,\n      transformOrigin: 'bottom center'\n    },\n    '&[data-popper-placement^=\"top\"] [data-popper-arrow]': {\n      bottom: arrowPos,\n      '&::before': {\n        boxShadow: \"2px 2px 2px 0 \" + arrowShadowColor\n      }\n    },\n    '&[data-popper-placement^=\"bottom\"]': {\n      marginTop: popoverMargin,\n      transformOrigin: 'top center'\n    },\n    '&[data-popper-placement^=\"bottom\"] [data-popper-arrow]': {\n      top: arrowPos,\n      '&::before': {\n        boxShadow: \"-1px -1px 1px 0 \" + arrowShadowColor\n      }\n    },\n    '&[data-popper-placement^=\"right\"]': {\n      marginLeft: popoverMargin,\n      transformOrigin: 'left center'\n    },\n    '&[data-popper-placement^=\"right\"] [data-popper-arrow]': {\n      left: arrowPos,\n      '&::before': {\n        boxShadow: \"-1px 1px 1px 0 \" + arrowShadowColor\n      }\n    },\n    '&[data-popper-placement^=\"left\"]': {\n      marginRight: popoverMargin,\n      transformOrigin: 'right center'\n    },\n    '&[data-popper-placement^=\"left\"] [data-popper-arrow]': {\n      right: arrowPos,\n      '&::before': {\n        boxShadow: \"1px -1px 1px 0 \" + arrowShadowColor\n      }\n    }\n  });\n};\n/**\n * Hey! Welcome to @chakra-ui/vue Popper\n *\n * The Popper component is an internal utility component used\n * to wrap the Popper.js library in to a Vue component\n */\n\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n/**\n * Flips placement if in <body dir=\"rtl\" />\n * @param {string} placement\n */\n\n\nfunction flipPlacement(placement) {\n  var direction = canUseDOM && document.body.getAttribute('dir') || 'ltr';\n\n  if (direction !== 'rtl') {\n    return placement;\n  }\n\n  switch (placement) {\n    case 'bottom-end':\n      return 'bottom-start';\n\n    case 'bottom-start':\n      return 'bottom-end';\n\n    case 'top-end':\n      return 'top-start';\n\n    case 'top-start':\n      return 'top-end';\n\n    default:\n      return placement;\n  }\n}\n/**\n * Call _.merge() for each item of `object` array with the corresponding\n * item of `source` array\n * @param {*} object The destination Modifiers array.\n * @param {*} source The source array.\n * @returns Returns merged `array`\n */\n\n\nfunction mergeModifiers(object, source) {\n  if (!Array.isArray(object)) {\n    throw new Error('`object` must be an array');\n  }\n\n  var _source = Array.isArray(source) ? source : [source];\n\n  object.forEach(function (o) {\n    var name = o.name;\n\n    var _s = _source.find(function (s) {\n      return s.name === name;\n    });\n\n    if (_s) {\n      merge(o, _s);\n    }\n  });\n  return object;\n}\n/**\n * CPopper component\n *\n * The popper.js component\n *\n * @extends CPseudoBox\n * @see PopperJs https://popper.js.org/\n */\n\n\nvar CPopper = {\n  name: 'CPopper',\n  inheritAttrs: false,\n  directives: {\n    ClickOutside: ClickOutside\n  },\n  props: {\n    as: {\n      type: [String, Object],\n      default: 'div'\n    },\n    isOpen: Boolean,\n    placement: {\n      type: String,\n      default: 'bottom',\n      validator: function validator(value) {\n        return value.match(/^(top|top-start|top-end|right|right-start|right-end|bottom|bottom-start|bottom-end|left|left-start|left-end)$/);\n      }\n    },\n    usePortal: {\n      type: Boolean,\n      default: true\n    },\n    onClose: {\n      type: Function,\n      default: function _default() {\n        return null;\n      }\n    },\n    closeOnClickAway: {\n      type: Boolean,\n      default: true\n    },\n    modifiers: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    anchorEl: HTMLElement$1,\n    eventsEnabled: {\n      type: Boolean,\n      default: true\n    },\n    arrowSize: {\n      type: String,\n      default: '1rem'\n    },\n    arrowShadowColor: {\n      type: String,\n      default: 'rgba(0, 0, 0, 0.1)'\n    },\n    hasArrow: {\n      type: Boolean,\n      default: true\n    },\n    positionFixed: Boolean,\n    usePortalTarget: String\n  },\n  data: function data() {\n    return {\n      popper: null,\n      referenceBackgroundColor: undefined\n    };\n  },\n  watch: {\n    placement: function placement(newValue) {\n      if (this.popper) {\n        this.popper.options.placement = newValue;\n        this.reference.setAttribute('data-show', '');\n      }\n    },\n    isOpen: function isOpen(newValue) {\n      if (newValue) {\n        this.handleOpen();\n      } else {\n        this.handleClose();\n      }\n    }\n  },\n  computed: {\n    arrowStyles: function arrowStyles() {\n      return getPopperArrowStyle({\n        arrowSize: this.arrowSize,\n        arrowShadowColor: this.arrowShadowColor,\n        hasArrow: this.hasArrow,\n        bg: this.referenceBackgroundColor\n      });\n    },\n    portalTarget: function portalTarget() {\n      return this.usePortalTarget || \"#chakra-portal-\" + useId(4);\n    },\n    popperId: function popperId() {\n      return \"popper_\" + useId(4);\n    },\n    rtlPlacement: function rtlPlacement() {\n      return flipPlacement(this.placement);\n    },\n    anchor: function anchor() {\n      return this.getNode(this.anchorEl);\n    },\n    reference: function reference() {\n      var ref = this.usePortal // There should be a much cleaner way to do this.\n      // But for now this works. Should return with bigger guns.\n      ? canUseDOM && document.querySelector(this.portalTarget).firstChild : this.getNode(this.$el);\n      return ref;\n    },\n    computedModifiers: function computedModifiers() {\n      return mergeModifiers([this.usePortal && {\n        name: 'preventOverflow',\n        options: {\n          boundary: 'window'\n        }\n      }, {\n        name: 'offset',\n        options: {\n          offset: [0, 10]\n        }\n      }, {\n        name: 'arrow',\n        options: {\n          element: '[data-popper-arrow]',\n          transform: 'rotate(45deg)'\n        }\n      }], this.modifiers);\n    }\n  },\n  methods: {\n    /**\n     * Handles open state for Popper\n     */\n    handleOpen: function handleOpen() {\n      var this$1 = this; // Double check to make sure portal target is mounted\n      // If it already is mounted, Portal component will use\n      // the existing portal target to mount popper children\n\n      this.usePortal && this.$refs.portalRef && this.$refs.portalRef.mountTarget();\n\n      if (!this.anchor || !this.reference) {\n        return;\n      }\n\n      if (this.popper) {\n        this.reference.setAttribute('data-show', '');\n        this.popper.update().then(function () {\n          if (this$1.hasArrow) {\n            var arrow = this$1.reference.querySelector(['[data-popper-arrow]']);\n\n            if (arrow) {\n              this$1.$nextTick(function () {\n                this$1.referenceBackgroundColor = getComputedStyle(this$1.reference).backgroundColor || getComputedStyle(this$1.reference).background;\n              });\n            }\n          }\n        });\n      } else {\n        this.popper = createPopper(this.anchor, this.reference, {\n          placement: this.rtlPlacement,\n          modifiers: this.computedModifiers,\n          onUpdate: createChainedFunction(this.handlePopperUpdate),\n          onFirstUpdate: createChainedFunction(this.handlePopperCreated),\n          eventListeners: {\n            resize: true,\n            scroll: true\n          },\n          eventsEnabled: this.eventsEnabled,\n          positionFixed: this.positionFixed\n        });\n        this.reference.setAttribute('data-show', '');\n        this.popper.update().then(function () {\n          if (this$1.hasArrow) {\n            var arrow = this$1.reference.querySelector(['[data-popper-arrow]']);\n\n            if (arrow) {\n              this$1.$nextTick(function () {\n                this$1.referenceBackgroundColor = getComputedStyle(this$1.reference).backgroundColor || getComputedStyle(this$1.reference).background;\n              });\n            }\n          }\n        });\n      }\n    },\n\n    /**\n     * Returns the HTML element of a Vue component or native element\n     * @param {Vue.Component|HTMLElement} element HTMLElement or Vue Component\n     */\n    getNode: function getNode(element) {\n      var isVue = isVueComponent(element);\n      return isVue ? element.$el : element;\n    },\n\n    /**\n     * Closes Popper Element\n     */\n    handleClose: function handleClose() {\n      if (this.popper) {\n        this.reference.removeAttribute('data-show');\n        this.$emit('close', {});\n      }\n    },\n\n    /**\n     * Wrapped handler for clickaway events\n     */\n    wrapClose: function wrapClose(e) {\n      if (this.popper && !this.anchor.contains(e.target)) {\n        this.closeOnClickAway && this.handleClose();\n      }\n    },\n\n    /**\n     * Handle's popper updates when update is called\n     * @param {Object} payload\n     */\n    handlePopperUpdate: function handlePopperUpdate(payload) {\n      this.$emit('update', payload);\n      this.isOpen && this.$emit('open');\n    },\n\n    /**\n     * Handle's popper updates when update is called\n     * @param {Object} payload\n     */\n    handlePopperCreated: function handlePopperCreated(payload) {\n      this.$emit('create', payload);\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.popper && this.popper.destroy();\n    this.popper = null;\n  },\n  render: function render(h) {\n    if (this.isOpen && !this.popper) {\n      this.handleOpen();\n    }\n\n    return h(CPortal, {\n      props: {\n        append: true,\n        target: this.portalTarget,\n        disabled: !this.usePortal,\n        slim: true,\n        unmountOnDestroy: true,\n        targetSlim: true\n      },\n      ref: 'portalRef'\n    }, [h(CPseudoBox, {\n      class: [this.arrowStyles],\n      style: {\n        display: this.isOpen ? 'unset' : 'none'\n      },\n      props: {\n        as: this.as\n      },\n      directives: [{\n        name: 'click-outside',\n        value: this.wrapClose\n      }],\n      attrs: Object.assign({}, this.$attrs, {\n        id: this.$attrs.id || \"chakra-\" + this.popperId,\n        'data-popper-id': \"chakra-\" + this.popperId,\n        'data-chakra-component': 'CPopper'\n      }),\n      scopedSlots: {\n        popperId: \"chakra-\" + this.popperId\n      },\n      ref: 'handleRef'\n    }, this.$slots.default)]);\n  }\n};\nvar CPopperArrow = {\n  name: 'CPopperArrow',\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var rest$1 = objectWithoutProperties(ref, [\"data\"]);\n    var rest = rest$1;\n    return h(CBox, Object.assign({}, rest, {\n      attrs: Object.assign({}, data.attrs, {\n        'x-arrow': true,\n        'data-popper-arrow': true,\n        role: 'presentation',\n        'data-chakra-component': 'CPopperArrow'\n      })\n    }));\n  }\n};\nexport { CPopper, CPopperArrow };","map":{"version":3,"names":["H","HTMLElement$1","J","useId","o","canUseDOM","N","createChainedFunction","P","isVueComponent","m","merge","C","ClickOutside","css","CBox","CPseudoBox","CPortal","getBoundingClientRect","element","rect","width","height","top","right","bottom","left","x","y","getWindow","node","toString","ownerDocument","defaultView","window","getWindowScroll","win","scrollLeft","pageXOffset","scrollTop","pageYOffset","isElement","OwnElement","Element","isHTMLElement","HTMLElement","getHTMLElementScroll","getNodeScroll","getNodeName","nodeName","toLowerCase","getDocumentElement","document","documentElement","getWindowScrollBarX","getComputedStyle$1","getComputedStyle","isScrollParent","_getComputedStyle","overflow","overflowX","overflowY","test","getCompositeRect","elementOrVirtualElement","offsetParent","isFixed","scroll","offsets","clientLeft","clientTop","getLayoutRect","offsetLeft","offsetTop","offsetWidth","offsetHeight","getParentNode","assignedSlot","parentNode","host","getScrollParent","indexOf","body","listScrollParents","list","scrollParent","isBody","target","concat","visualViewport","updatedList","isTableElement","getTrueOffsetParent","position","getOffsetParent","auto","basePlacements","start","end","clippingParents","viewport","popper","reference","variationPlacements","reduce","acc","placement","placements","beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite","modifierPhases","order","modifiers","map","Map","visited","Set","result","forEach","modifier","set","name","sort","add","requires","requiresIfExists","dep","has","depModifier","get","push","orderModifiers","orderedModifiers","phase","filter","debounce","fn","pending","Promise","resolve","then","undefined","format","str","arguments$1","arguments","_len","length","args","Array","_key","p","c","replace","INVALID_MODIFIER_ERROR","MISSING_DEPENDENCY_ERROR","VALID_PROPERTIES","validateModifiers","Object","keys","key","console","error","String","enabled","join","effect","isArray","s","requirement","find","mod","uniqueBy","arr","identifiers","item","identifier","getBasePlacement","split","mergeByName","merged","current","existing","assign","options","data","INVALID_ELEMENT_ERROR","INFINITE_LOOP_ERROR","DEFAULT_OPTIONS","strategy","areValidElements","some","popperGenerator","generatorOptions","_generatorOptions","_generatorOptions$def","defaultModifiers","_generatorOptions$def2","defaultOptions","createPopper","state","modifiersData","elements","attributes","styles","effectCleanupFns","isDestroyed","instance","setOptions","cleanupModifierEffects","scrollParents","contextElement","process","env","NODE_ENV","_ref","flipModifier","_ref2","marginTop","marginRight","marginBottom","marginLeft","margin","parseFloat","warn","runModifierEffects","update","forceUpdate","_state$elements","rects","reset","__debug_loops__","index","_state$orderedModifie","_state$orderedModifie2","_options","destroy","onFirstUpdate","_ref3","_ref3$options","cleanupFn","noopFn","passive","_options$scroll","_options$resize","resize","addEventListener","removeEventListener","eventListeners","getVariation","getMainAxisFromPlacement","computeOffsets","basePlacement","variation","commonX","commonY","mainAxis","len","Math","floor","ceil","popperOffsets","popperOffsets$1","unsetSides","roundOffsets","dpr","devicePixelRatio","round","mapToStyles","_Object$assign2","popperRect","gpuAcceleration","adaptive","_roundOffsets","hasX","hasOwnProperty","hasY","sideX","sideY","clientHeight","clientWidth","commonStyles","_Object$assign","transform","computeStyles","_options$gpuAccelerat","_options$adaptive","transitionProperty","property","arrow","computeStyles$1","applyStyles","style","value","removeAttribute","setAttribute","effect$1","initialStyles","styleProperties","attribute","applyStyles$1","distanceAndSkiddingToXY","offset","invertDistance","skidding","distance","_options$offset","_data$state$placement","offset$1","hash","getOppositePlacement","matched","hash$1","getOppositeVariationPlacement","getViewportRect","innerWidth","innerHeight","navigator","platform","getDocumentRect","winScroll","documentRect","max","toNumber","cssValue","getBorders","computedStyle","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","getDecorations","borders","isHTML","winScrollBarX","contains","parent","child","isShadow","Boolean","getRootNode","next","isSameNode","rectToClientRect","getClientRectFromMixedType","clippingParent","getClippingParents","canEscapeClipping","clipperElement","getClippingRect","boundary","rootBoundary","mainClippingParents","firstClippingParent","clippingRect","accRect","decorations","min","getFreshSideObject","mergePaddingObject","paddingObject","expandToHashMap","hashMap","detectOverflow","_options$placement","_options$boundary","_options$rootBoundary","_options$elementConte","elementContext","_options$altBoundary","altBoundary","_options$padding","padding","altContext","referenceElement","clippingClientRect","referenceClientRect","popperClientRect","elementClientRect","overflowOffsets","offsetData","multiply","axis","computeAutoPlacement","flipVariations","_options$allowedAutoP","allowedAutoPlacements","placements$1","overflows","a","b","getExpandedFallbackPlacements","oppositePlacement","flip","_skip","_options$mainAxis","checkMainAxis","_options$altAxis","altAxis","checkAltAxis","specifiedFallbackPlacements","fallbackPlacements","_options$flipVariatio","preferredPlacement","isBasePlacement","referenceRect","checksMap","makeFallbackChecks","firstFittingPlacement","i","_basePlacement","isStartVariation","isVertical","mainVariationSide","altVariationSide","checks","every","check","numberOfChecks","_loop","_i","fittingPlacement","slice","_ret","flip$1","getAltAxis","within","preventOverflow","_options$tether","tether","_options$tetherOffset","tetherOffset","tetherOffsetValue","mainSide","altSide","additive","minLen","maxLen","arrowElement","arrowRect","arrowPaddingObject","arrowPaddingMin","arrowPaddingMax","arrowLen","minOffset","maxOffset","arrowOffsetParent","clientOffset","offsetModifierValue","tetherMin","tetherMax","preventedOffset","_mainSide","_altSide","_offset","_min","_max","_preventedOffset","preventOverflow$1","_state$modifiersData$","minProp","maxProp","endDiff","startDiff","clientSize","centerToReference","center","axisProp","centerOffset","effect$2","_options$element","querySelector","arrow$1","getSideOffsets","preventedOffsets","isAnySideFullyClipped","side","hide","referenceOverflow","popperAltOverflow","referenceClippingOffsets","popperEscapeOffsets","isReferenceHidden","hasPopperEscaped","hide$1","getPopperArrowStyle","ref","arrowSize","arrowShadowColor","hasArrow","bg","popoverMargin","arrowPos","display","zIndex","content","backgroundColor","transformOrigin","boxShadow","objectWithoutProperties","obj","exclude","k","prototype","call","flipPlacement","direction","getAttribute","mergeModifiers","object","source","Error","_source","_s","CPopper","inheritAttrs","directives","props","as","type","default","isOpen","validator","match","usePortal","onClose","Function","_default","closeOnClickAway","anchorEl","eventsEnabled","positionFixed","usePortalTarget","referenceBackgroundColor","watch","newValue","handleOpen","handleClose","computed","arrowStyles","portalTarget","popperId","rtlPlacement","anchor","getNode","firstChild","$el","computedModifiers","methods","this$1","$refs","portalRef","mountTarget","$nextTick","background","onUpdate","handlePopperUpdate","handlePopperCreated","isVue","$emit","wrapClose","e","payload","beforeDestroy","render","h","append","disabled","slim","unmountOnDestroy","targetSlim","class","attrs","$attrs","id","scopedSlots","$slots","CPopperArrow","functional","rest$1","rest","role"],"sources":["/Users/user/Documents/GitHub/frontend-eng-assessment/node_modules/@chakra-ui/vue/dist/esm/CPopper.js"],"sourcesContent":["\n/*\n * ! @chakra-ui/vue v0.12.0 by Jonathan Bakebwa @codebender828\n * MIT License\n * https://github.com/chakra-ui/chakra-ui-vue\n */\n\nimport { H as HTMLElement$1, J as useId, o as canUseDOM, N as createChainedFunction, P as isVueComponent, m as merge } from './index-2557a15f.js';\nimport './chakra-ui-styled-system.esm-36097b89.js';\nimport { C as ClickOutside } from './clickoutside.directive-97f28484.js';\nimport { css } from '@emotion/css';\nimport 'vue';\nimport './color-mode-observer-d3e4ca7f.js';\nimport CBox from './CBox.js';\nimport CPseudoBox from './CPseudoBox.js';\nimport CPortal from './CPortal.js';\nimport './CNoSsr.js';\n\nfunction getBoundingClientRect(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    y: rect.top\n  };\n}\n\n/*:: import type { Window } from '../types'; */\n\n/*:: declare function getWindow(node: Node | Window): Window; */\nfunction getWindow(node) {\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView : window;\n  }\n\n  return node;\n}\n\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n\n/*:: declare function isElement(node: mixed): boolean %checks(node instanceof\n  Element); */\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof\n  HTMLElement); */\n\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe: assume body is always available\n  return (isElement(element) ? element.ownerDocument : element.document).documentElement;\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle$1(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n\n// Composite means it takes into account transforms as well as layout.\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (!isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\n// Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\nfunction getLayoutRect(element) {\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  };\n}\n\nfunction getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || // DOM Element detected\n    // $FlowFixMe: need a better way to handle this...\n    element.host || // ShadowRoot detected\n    // $FlowFixMe: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n\nfunction listScrollParents(element, list) {\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = getNodeName(scrollParent) === 'body';\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element); // Find the nearest non-table offsetParent\n\n  while (offsetParent && isTableElement(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static') {\n    return window;\n  }\n\n  return offsetParent || window;\n}\n\nvar top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar auto = 'auto';\nvar basePlacements = [top, bottom, right, left];\nvar start = 'start';\nvar end = 'end';\nvar clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar popper = 'popper';\nvar reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n\nfunction format(str) {\n  var arguments$1 = arguments;\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments$1[_key];\n  }\n\n  return [].concat(args).reduce(function (p, c) {\n    return p.replace(/%s/, c);\n  }, str);\n}\n\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s';\nvar MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available';\nvar VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];\nfunction validateModifiers(modifiers) {\n  modifiers.forEach(function (modifier) {\n    Object.keys(modifier).forEach(function (key) {\n      switch (key) {\n        case 'name':\n          if (typeof modifier.name !== 'string') {\n            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '\"name\"', '\"string\"', \"\\\"\" + String(modifier.name) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'enabled':\n          if (typeof modifier.enabled !== 'boolean') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"enabled\"', '\"boolean\"', \"\\\"\" + String(modifier.enabled) + \"\\\"\"));\n          }\n\n        case 'phase':\n          if (modifierPhases.indexOf(modifier.phase) < 0) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"phase\"', \"either \" + modifierPhases.join(', '), \"\\\"\" + String(modifier.phase) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'fn':\n          if (typeof modifier.fn !== 'function') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"fn\"', '\"function\"', \"\\\"\" + String(modifier.fn) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'effect':\n          if (typeof modifier.effect !== 'function') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"effect\"', '\"function\"', \"\\\"\" + String(modifier.fn) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'requires':\n          if (!Array.isArray(modifier.requires)) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requires\"', '\"array\"', \"\\\"\" + String(modifier.requires) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'requiresIfExists':\n          if (!Array.isArray(modifier.requiresIfExists)) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requiresIfExists\"', '\"array\"', \"\\\"\" + String(modifier.requiresIfExists) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'options':\n        case 'data':\n          break;\n\n        default:\n          console.error(\"PopperJS: an invalid property has been provided to the \\\"\" + modifier.name + \"\\\" modifier, valid properties are \" + VALID_PROPERTIES.map(function (s) {\n            return \"\\\"\" + s + \"\\\"\";\n          }).join(', ') + \"; but \\\"\" + key + \"\\\" was provided.\");\n      }\n\n      modifier.requires && modifier.requires.forEach(function (requirement) {\n        if (modifiers.find(function (mod) {\n          return mod.name === requirement;\n        }) == null) {\n          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));\n        }\n      });\n    });\n  });\n}\n\nfunction uniqueBy(arr, fn) {\n  var identifiers = new Set();\n  return arr.filter(function (item) {\n    var identifier = fn(item);\n\n    if (!identifiers.has(identifier)) {\n      identifiers.add(identifier);\n      return true;\n    }\n  });\n}\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\n\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, {}, current, {\n      options: Object.assign({}, existing.options, {}, current.options),\n      data: Object.assign({}, existing.data, {}, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}\n\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  var arguments$1 = arguments;\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments$1[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, {}, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, {}, state.options, {}, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (process.env.NODE_ENV !== \"production\") {\n          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === 'flip';\n            });\n\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n\n          var _getComputedStyle = getComputedStyle$1(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (process.env.NODE_ENV !== \"production\") {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar eventListeners = {\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n};\n\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);\n        break;\n    }\n  }\n\n  return offsets;\n}\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar popperOffsets$1 = {\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n};\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsets(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive;\n\n  var _roundOffsets = roundOffsets(offsets),\n      x = _roundOffsets.x,\n      y = _roundOffsets.y;\n\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n    /*:: offsetParent = (offsetParent: Element); */\n\n\n    if (placement === top) {\n      sideY = bottom;\n      y -= offsetParent.clientHeight - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left) {\n      sideX = right;\n      x -= offsetParent.clientWidth - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref3) {\n  var state = _ref3.state,\n      options = _ref3.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';\n\n    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {\n      return transitionProperty.indexOf(property) >= 0;\n    })) {\n      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', '\\n\\n', 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\\n\\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));\n    }\n  }\n\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar computeStyles$1 = {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n};\n\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect$1(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe\n\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar applyStyles$1 = {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect$1,\n  requires: ['computeStyles']\n};\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar offset$1 = {\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n};\n\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\nvar hash$1 = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash$1[matched];\n  });\n}\n\nfunction getViewportRect(element) {\n  var win = getWindow(element);\n  var visualViewport = win.visualViewport;\n  var width = win.innerWidth;\n  var height = win.innerHeight; // We don't know which browsers have buggy or odd implementations of this, so\n  // for now we're only applying it to iOS to fix the keyboard issue.\n  // Investigation required\n\n  if (visualViewport && /iPhone|iPod|iPad/.test(navigator.platform)) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: 0,\n    y: 0\n  };\n}\n\nfunction getDocumentRect(element) {\n  var win = getWindow(element);\n  var winScroll = getWindowScroll(element);\n  var documentRect = getCompositeRect(getDocumentElement(element), win);\n  documentRect.height = Math.max(documentRect.height, win.innerHeight);\n  documentRect.width = Math.max(documentRect.width, win.innerWidth);\n  documentRect.x = -winScroll.scrollLeft;\n  documentRect.y = -winScroll.scrollTop;\n  return documentRect;\n}\n\nfunction toNumber(cssValue) {\n  return parseFloat(cssValue) || 0;\n}\n\nfunction getBorders(element) {\n  var computedStyle = isHTMLElement(element) ? getComputedStyle$1(element) : {};\n  return {\n    top: toNumber(computedStyle.borderTopWidth),\n    right: toNumber(computedStyle.borderRightWidth),\n    bottom: toNumber(computedStyle.borderBottomWidth),\n    left: toNumber(computedStyle.borderLeftWidth)\n  };\n}\n\nfunction getDecorations(element) {\n  var win = getWindow(element);\n  var borders = getBorders(element);\n  var isHTML = getNodeName(element) === 'html';\n  var winScrollBarX = getWindowScrollBarX(element);\n  var x = element.clientWidth + borders.right;\n  var y = element.clientHeight + borders.bottom; // HACK:\n  // document.documentElement.clientHeight on iOS reports the height of the\n  // viewport including the bottom bar, even if the bottom bar isn't visible.\n  // If the difference between window innerHeight and html clientHeight is more\n  // than 50, we assume it's a mobile bottom bar and ignore scrollbars.\n  // * A 50px thick scrollbar is likely non-existent (macOS is 15px and Windows\n  //   is about 17px)\n  // * The mobile bar is 114px tall\n\n  if (isHTML && win.innerHeight - element.clientHeight > 50) {\n    y = win.innerHeight - borders.bottom;\n  }\n\n  return {\n    top: isHTML ? 0 : element.clientTop,\n    right: // RTL scrollbar (scrolling containers only)\n    element.clientLeft > borders.left ? borders.right : // LTR scrollbar\n    isHTML ? win.innerWidth - x - winScrollBarX : element.offsetWidth - x,\n    bottom: isHTML ? win.innerHeight - y : element.offsetHeight - y,\n    left: isHTML ? winScrollBarX : element.clientLeft\n  };\n}\n\nfunction contains(parent, child) {\n  // $FlowFixMe: hasOwnProperty doesn't seem to work in tests\n  var isShadow = Boolean(child.getRootNode && child.getRootNode().host); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (isShadow) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}\n\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(element);\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement);\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    var decorations = getDecorations(isHTMLElement(clippingParent) ? clippingParent : getDocumentElement(element));\n    accRect.top = Math.max(rect.top + decorations.top, accRect.top);\n    accRect.right = Math.min(rect.right - decorations.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom - decorations.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left + decorations.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), {}, paddingObject);\n}\n\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var referenceElement = state.elements.reference;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(referenceElement);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, {}, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n\n/*:: type OverflowsMap = { [ComputedPlacement]: number }; */\n\n/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements$1 = (variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements).filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  }); // $FlowFixMe: Flow seems to have problems with two array unions...\n\n  var overflows = placements$1.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") { break; }\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar flip$1 = {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};\n\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\nfunction within(min, value, max) {\n  return Math.max(min, Math.min(value, max));\n}\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var _preventedOffset = within(_min, _offset, _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar preventOverflow$1 = {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = state.modifiersData[name + \"#persistent\"].padding;\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect$2(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,\n      _options$padding = options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!isHTMLElement(arrowElement)) {\n      console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n    }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n  state.modifiersData[name + \"#persistent\"] = {\n    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar arrow$1 = {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect$2,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar hide$1 = {\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n};\n\nvar defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\nvar createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n/**\n * Evaluates popper arrow styles\n * @param {{ arrowSize: String, arrowShadowColor: String, hasArrow: Boolean}} props\n * @returns {String} Popper Arrow styles\n */\n\nvar getPopperArrowStyle = function getPopperArrowStyle(ref) {\n  var arrowSize = ref.arrowSize;\n  if (arrowSize === void 0) arrowSize = '1rem';\n  var arrowShadowColor = ref.arrowShadowColor;\n  if (arrowShadowColor === void 0) arrowShadowColor = 'rgba(0, 0, 0, 0.1)';\n  var hasArrow = ref.hasArrow;\n  if (hasArrow === void 0) hasArrow = true;\n  var bg = ref.bg;\n  if (bg === void 0) bg = 'inherit';\n  var popoverMargin = hasArrow ? \"calc(\" + arrowSize + \" / 2)\" : null;\n  var arrowPos = \"calc(\" + arrowSize + \" / 2 * -1)\";\n  return css({\n    display: 'none',\n    '[data-show]': {\n      display: 'block'\n    },\n    '[data-popper-arrow]': {\n      position: 'absolute',\n      zIndex: -1,\n      '&::before': {\n        content: '\"\"',\n        transform: 'rotate(45deg)',\n        backgroundColor: bg,\n        display: 'block',\n        width: arrowSize,\n        height: arrowSize\n      }\n    },\n    '&[data-popper-placement^=\"top\"]': {\n      marginBottom: popoverMargin,\n      transformOrigin: 'bottom center'\n    },\n    '&[data-popper-placement^=\"top\"] [data-popper-arrow]': {\n      bottom: arrowPos,\n      '&::before': {\n        boxShadow: \"2px 2px 2px 0 \" + arrowShadowColor\n      }\n    },\n    '&[data-popper-placement^=\"bottom\"]': {\n      marginTop: popoverMargin,\n      transformOrigin: 'top center'\n    },\n    '&[data-popper-placement^=\"bottom\"] [data-popper-arrow]': {\n      top: arrowPos,\n      '&::before': {\n        boxShadow: \"-1px -1px 1px 0 \" + arrowShadowColor\n      }\n    },\n    '&[data-popper-placement^=\"right\"]': {\n      marginLeft: popoverMargin,\n      transformOrigin: 'left center'\n    },\n    '&[data-popper-placement^=\"right\"] [data-popper-arrow]': {\n      left: arrowPos,\n      '&::before': {\n        boxShadow: \"-1px 1px 1px 0 \" + arrowShadowColor\n      }\n    },\n    '&[data-popper-placement^=\"left\"]': {\n      marginRight: popoverMargin,\n      transformOrigin: 'right center'\n    },\n    '&[data-popper-placement^=\"left\"] [data-popper-arrow]': {\n      right: arrowPos,\n      '&::before': {\n        boxShadow: \"1px -1px 1px 0 \" + arrowShadowColor\n      }\n    }\n  });\n};\n\n/**\n * Hey! Welcome to @chakra-ui/vue Popper\n *\n * The Popper component is an internal utility component used\n * to wrap the Popper.js library in to a Vue component\n */\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n/**\n * Flips placement if in <body dir=\"rtl\" />\n * @param {string} placement\n */\n\nfunction flipPlacement(placement) {\n  var direction = canUseDOM && document.body.getAttribute('dir') || 'ltr';\n\n  if (direction !== 'rtl') {\n    return placement;\n  }\n\n  switch (placement) {\n    case 'bottom-end':\n      return 'bottom-start';\n\n    case 'bottom-start':\n      return 'bottom-end';\n\n    case 'top-end':\n      return 'top-start';\n\n    case 'top-start':\n      return 'top-end';\n\n    default:\n      return placement;\n  }\n}\n/**\n * Call _.merge() for each item of `object` array with the corresponding\n * item of `source` array\n * @param {*} object The destination Modifiers array.\n * @param {*} source The source array.\n * @returns Returns merged `array`\n */\n\n\nfunction mergeModifiers(object, source) {\n  if (!Array.isArray(object)) {\n    throw new Error('`object` must be an array');\n  }\n\n  var _source = Array.isArray(source) ? source : [source];\n\n  object.forEach(function (o) {\n    var name = o.name;\n\n    var _s = _source.find(function (s) {\n      return s.name === name;\n    });\n\n    if (_s) {\n      merge(o, _s);\n    }\n  });\n  return object;\n}\n/**\n * CPopper component\n *\n * The popper.js component\n *\n * @extends CPseudoBox\n * @see PopperJs https://popper.js.org/\n */\n\n\nvar CPopper = {\n  name: 'CPopper',\n  inheritAttrs: false,\n  directives: {\n    ClickOutside: ClickOutside\n  },\n  props: {\n    as: {\n      type: [String, Object],\n      default: 'div'\n    },\n    isOpen: Boolean,\n    placement: {\n      type: String,\n      default: 'bottom',\n      validator: function validator(value) {\n        return value.match(/^(top|top-start|top-end|right|right-start|right-end|bottom|bottom-start|bottom-end|left|left-start|left-end)$/);\n      }\n    },\n    usePortal: {\n      type: Boolean,\n      default: true\n    },\n    onClose: {\n      type: Function,\n      default: function _default() {\n        return null;\n      }\n    },\n    closeOnClickAway: {\n      type: Boolean,\n      default: true\n    },\n    modifiers: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    anchorEl: HTMLElement$1,\n    eventsEnabled: {\n      type: Boolean,\n      default: true\n    },\n    arrowSize: {\n      type: String,\n      default: '1rem'\n    },\n    arrowShadowColor: {\n      type: String,\n      default: 'rgba(0, 0, 0, 0.1)'\n    },\n    hasArrow: {\n      type: Boolean,\n      default: true\n    },\n    positionFixed: Boolean,\n    usePortalTarget: String\n  },\n  data: function data() {\n    return {\n      popper: null,\n      referenceBackgroundColor: undefined\n    };\n  },\n  watch: {\n    placement: function placement(newValue) {\n      if (this.popper) {\n        this.popper.options.placement = newValue;\n        this.reference.setAttribute('data-show', '');\n      }\n    },\n    isOpen: function isOpen(newValue) {\n      if (newValue) {\n        this.handleOpen();\n      } else {\n        this.handleClose();\n      }\n    }\n  },\n  computed: {\n    arrowStyles: function arrowStyles() {\n      return getPopperArrowStyle({\n        arrowSize: this.arrowSize,\n        arrowShadowColor: this.arrowShadowColor,\n        hasArrow: this.hasArrow,\n        bg: this.referenceBackgroundColor\n      });\n    },\n    portalTarget: function portalTarget() {\n      return this.usePortalTarget || \"#chakra-portal-\" + useId(4);\n    },\n    popperId: function popperId() {\n      return \"popper_\" + useId(4);\n    },\n    rtlPlacement: function rtlPlacement() {\n      return flipPlacement(this.placement);\n    },\n    anchor: function anchor() {\n      return this.getNode(this.anchorEl);\n    },\n    reference: function reference() {\n      var ref = this.usePortal // There should be a much cleaner way to do this.\n      // But for now this works. Should return with bigger guns.\n      ? canUseDOM && document.querySelector(this.portalTarget).firstChild : this.getNode(this.$el);\n      return ref;\n    },\n    computedModifiers: function computedModifiers() {\n      return mergeModifiers([this.usePortal && {\n        name: 'preventOverflow',\n        options: {\n          boundary: 'window'\n        }\n      }, {\n        name: 'offset',\n        options: {\n          offset: [0, 10]\n        }\n      }, {\n        name: 'arrow',\n        options: {\n          element: '[data-popper-arrow]',\n          transform: 'rotate(45deg)'\n        }\n      }], this.modifiers);\n    }\n  },\n  methods: {\n    /**\n     * Handles open state for Popper\n     */\n    handleOpen: function handleOpen() {\n      var this$1 = this; // Double check to make sure portal target is mounted\n      // If it already is mounted, Portal component will use\n      // the existing portal target to mount popper children\n\n      this.usePortal && this.$refs.portalRef && this.$refs.portalRef.mountTarget();\n\n      if (!this.anchor || !this.reference) {\n        return;\n      }\n\n      if (this.popper) {\n        this.reference.setAttribute('data-show', '');\n        this.popper.update().then(function () {\n          if (this$1.hasArrow) {\n            var arrow = this$1.reference.querySelector(['[data-popper-arrow]']);\n\n            if (arrow) {\n              this$1.$nextTick(function () {\n                this$1.referenceBackgroundColor = getComputedStyle(this$1.reference).backgroundColor || getComputedStyle(this$1.reference).background;\n              });\n            }\n          }\n        });\n      } else {\n        this.popper = createPopper(this.anchor, this.reference, {\n          placement: this.rtlPlacement,\n          modifiers: this.computedModifiers,\n          onUpdate: createChainedFunction(this.handlePopperUpdate),\n          onFirstUpdate: createChainedFunction(this.handlePopperCreated),\n          eventListeners: {\n            resize: true,\n            scroll: true\n          },\n          eventsEnabled: this.eventsEnabled,\n          positionFixed: this.positionFixed\n        });\n        this.reference.setAttribute('data-show', '');\n        this.popper.update().then(function () {\n          if (this$1.hasArrow) {\n            var arrow = this$1.reference.querySelector(['[data-popper-arrow]']);\n\n            if (arrow) {\n              this$1.$nextTick(function () {\n                this$1.referenceBackgroundColor = getComputedStyle(this$1.reference).backgroundColor || getComputedStyle(this$1.reference).background;\n              });\n            }\n          }\n        });\n      }\n    },\n\n    /**\n     * Returns the HTML element of a Vue component or native element\n     * @param {Vue.Component|HTMLElement} element HTMLElement or Vue Component\n     */\n    getNode: function getNode(element) {\n      var isVue = isVueComponent(element);\n      return isVue ? element.$el : element;\n    },\n\n    /**\n     * Closes Popper Element\n     */\n    handleClose: function handleClose() {\n      if (this.popper) {\n        this.reference.removeAttribute('data-show');\n        this.$emit('close', {});\n      }\n    },\n\n    /**\n     * Wrapped handler for clickaway events\n     */\n    wrapClose: function wrapClose(e) {\n      if (this.popper && !this.anchor.contains(e.target)) {\n        this.closeOnClickAway && this.handleClose();\n      }\n    },\n\n    /**\n     * Handle's popper updates when update is called\n     * @param {Object} payload\n     */\n    handlePopperUpdate: function handlePopperUpdate(payload) {\n      this.$emit('update', payload);\n      this.isOpen && this.$emit('open');\n    },\n\n    /**\n     * Handle's popper updates when update is called\n     * @param {Object} payload\n     */\n    handlePopperCreated: function handlePopperCreated(payload) {\n      this.$emit('create', payload);\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.popper && this.popper.destroy();\n    this.popper = null;\n  },\n  render: function render(h) {\n    if (this.isOpen && !this.popper) {\n      this.handleOpen();\n    }\n\n    return h(CPortal, {\n      props: {\n        append: true,\n        target: this.portalTarget,\n        disabled: !this.usePortal,\n        slim: true,\n        unmountOnDestroy: true,\n        targetSlim: true\n      },\n      ref: 'portalRef'\n    }, [h(CPseudoBox, {\n      class: [this.arrowStyles],\n      style: {\n        display: this.isOpen ? 'unset' : 'none'\n      },\n      props: {\n        as: this.as\n      },\n      directives: [{\n        name: 'click-outside',\n        value: this.wrapClose\n      }],\n      attrs: Object.assign({}, this.$attrs, {\n        id: this.$attrs.id || \"chakra-\" + this.popperId,\n        'data-popper-id': \"chakra-\" + this.popperId,\n        'data-chakra-component': 'CPopper'\n      }),\n      scopedSlots: {\n        popperId: \"chakra-\" + this.popperId\n      },\n      ref: 'handleRef'\n    }, this.$slots.default)]);\n  }\n};\nvar CPopperArrow = {\n  name: 'CPopperArrow',\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var rest$1 = objectWithoutProperties(ref, [\"data\"]);\n    var rest = rest$1;\n    return h(CBox, Object.assign({}, rest, {\n      attrs: Object.assign({}, data.attrs, {\n        'x-arrow': true,\n        'data-popper-arrow': true,\n        role: 'presentation',\n        'data-chakra-component': 'CPopperArrow'\n      })\n    }));\n  }\n};\n\nexport { CPopper, CPopperArrow };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}